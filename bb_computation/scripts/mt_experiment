#!/usr/bin/env python

"""

mt_experiment

This script is for running the BeetleBot modality transfer
experiment.

The robot will be initialised with a specific goal direction.  It will
then wait for the user to press the RETURN key.  The BeetleBot will
then perform an orientation dance and travel for 35cm (displacement)
which should reach approximately the experimental edge where the exit
angle can be taken.

Depends on getch:
$ pip install getch

"""

import rospy
import getch
import sys

from bb_util.msg import cue_msg
from bb_util.msg import erm_status
from bb_util.msg import ring_mapping
from bb_util.srv import velocity

from extended_ring_model import *
from dict_key_definitions import *

from nav_msgs.msg import Odometry
from geometry_msgs.msg import Twist
from std_msgs.msg import Float64
from rospy.numpy_msg import numpy_msg

use_efference = True

erm = RingModel()
c1_end, c2_end = erm.initialise()

# Globals
angular_velocity = 0

th_intensity = 0
th_wind = 0

w_intensity = 0.5
w_wind = 0.5

yaw = 0

def efference_av_callback(data):
    global angular_velocity
    angular_velocity = data.angular.z

def yaw_callback(msg):
    global yaw
    yaw = msg.data

def wind_cue_callback(data):
    global th_wind
    global w_wind
    th_wind = np.degrees(data.theta)
    w_wind = 0.5 if data.contrast > 0 else 0


def intensity_cue_callback(data):
    global th_intensity
    global w_intensiy
    th_intensity = np.degrees(data.theta)
    w_intensity = 0.5 if data.contrast > 0.1 else 0


def get_erm_status_as_msg():
    msg = erm_status()
    msg.r1 = erm.r1_rates
    msg.r2 = erm.r2_rates
    msg.epg = erm.epg_rates
    msg.d7 = erm.d7_rates
    msg.pen = erm.pen_rates
    msg.peg = erm.peg_rates

    n_r1 = erm.n_r1
    n_r2 = erm.n_r2
    n_epg = erm.n_epg
    len_r1 = n_r1*n_epg
    len_r2 = n_r2*n_epg

    msg.r1_epg = list(np.reshape(erm.w_r1_epg, (len_r1,)))
    msg.r2_epg = list(np.reshape(erm.w_r2_epg, (len_r2,)))
    msg.n_r1 = erm.n_r1
    msg.n_r2 = erm.n_r2
    msg.n_epg = erm.n_epg
    return msg

def print_instructions():
    print("This node generates scripted behaviour for the BeetleBot modality")
    print("transfer experiment.")
    print("")
    print("Controls:")
    print("g -> go: dance then move in the goal direction")
    print("s -> stop all movement (also ends the menotactic run).")
    print("e -> exit, close this node (will also stop the robot).")

def process_input(inchar):
    inchar = str(inchar)
    if inchar == "g":
        return "dance"
    if inchar == "s":
        return "stopped"
    if inchar == "e":
        print("Exiting...")
        sys.exit(0)


def node():
    global w_wind
    global w_intensity
    global yaw
    rospy.init_node("erm_node")

    # Rospy subscribers are implicitly started in their own threads
    rospy.Subscriber("cmd_vel", Twist,  efference_av_callback)
    rospy.Subscriber("yaw", Float64, yaw_callback)
    rospy.Subscriber("wind_cue", cue_msg, wind_cue_callback)
    rospy.Subscriber("intensity_cue", cue_msg, intensity_cue_callback)

    pub = rospy.Publisher("erm_status", numpy_msg(erm_status), queue_size=10)

    cmd_vel_service = rospy.ServiceProxy('update_velocity', velocity)

    # Goal direction w.r.t. E-PG preferences
    goal_direction = 0 # np.random.uniform(-np.pi, np.pi)
    distance_travelled = 0
    arena_radius = 35
    
    loop_hz = 10
    rosrate = rospy.Rate(loop_hz)

    print_instructions()

    context = "stopped"

    while not rospy.is_shutdown():
        # Get keyboard input
        context = process_input(getch.getch())
        if context == "dance":
            traverse = 0 # Total distance covered.
            previous = yaw
            while True:
                current_vec = np.array([np.cos(yaw), np.sin(yaw)])
                previous_vec = np.array([np.cos(previous), np.sin(previous)])
        
                dot = np.clip(-1,1,np.dot(current_vec, previous_vec))
                inner_angle = np.arccos(dot)
                print("{}, {}, {}".format(
                    np.degrees(previous),
                    np.degrees(yaw),
                    np.degrees(inner_angle))
                )
    
                traverse += inner_angle
                cmd_vel_service(0, 0.3, 0)
                previous = yaw

                # Loop end condition, done here so as to avoid
                # sleeping for 10ms before checking the condition at
                # the start of the loop.
                if traverse >= 2*np.pi:
                    break

                # Sleep so we have enough of a break between measurements
                # to actually detect a difference.
                rosrate.sleep()

            cmd_vel_service(0, 0, 0)

        # Convert Rad/s to Deg/s then scale for loop rate.
        av = -(np.degrees(angular_velocity)) / loop_hz

        w_intensity = w_intensity / (w_intensity + w_wind)
        w_wind = 1 - w_intensity
        erm.update_state(th_intensity,
                         th_wind,
                         av,
                         w1=w_intensity/(w_intensity + w_wind),
                         w2=w_wind/(w_intensity+w_wind),
                         av_plasticity=True
        )


        # steering = erm.steering(goal_direction)
        
        msg = get_erm_status_as_msg()
        pub.publish(msg)
        rosrate.sleep()



if __name__ == "__main__":
    node()

