#include <ros/ros.h>
#include <image_transport/image_transport.h>
#include <cv_bridge/cv_bridge.h>
#include <sensor_msgs/image_encodings.h>

#include <opencv2/opencv.hpp>
#include <opencv2/imgproc/imgproc.hpp>
#include <opencv2/highgui/highgui.hpp>

#include "image_processing/image_processing.hpp"
#include "image_processing/centroid_vector.h"
#include "image_processing/argparse.h"

#include <sstream>

image_processing::centroid_vector cv_msg;

//Global, bad but should be safe in this case
argparse::ArgumentParser parser("Parser");

bool initParser(argparse::ArgumentParser &parser, int argc, char **argv){
  //Global, all image_processing nodes should have these options.
  parser.add_argument()
    .names({"-v", "--video"})
    .description("Enable video output for this node.")
    .required(false);

  parser.add_argument()
    .names({"-s", "--subscribe"})
    .description("Override the subscription topic.")
    .required(true);

  parser.add_argument()
    .names({"-p", "--publish"})
    .description("Override the publication topic.")
    .required(true);

  parser.add_argument()
    .names({"-n", "--name"})
    .description("Override the node name.")
    .required(true);

  parser.enable_help();

  auto err = parser.parse(argc, const_cast<const char**>(argv));
  if (err) {
    std::stringstream ss;
    ss << err;
    ROS_ERROR("argparse error: %s", ss.str().c_str());
    return false;
  }

  return true;
}

void imageCallback(const sensor_msgs::ImageConstPtr& msg){
  cv::Mat frame;
  try{
    frame = cv_bridge::toCvCopy(msg, "mono8")->image;
  } catch (cv_bridge::Exception &e){
    ROS_ERROR("cv_bridge error: %s", e.what());
    ROS_INFO("This node should be subscribed to a topic producing grayscale (mono8) images");
  }

  //Compute adaptive binary image
  //cv::adaptiveThreshold(frame, frame, 127, cv::ADAPTIVE_THRESH_MEAN_C , cv::THRESH_BINARY, 3, 0);
  cv::threshold(frame, frame, 50, 255, cv::THRESH_BINARY);

  if (parser.exists("video")){
    cv::imshow("Thresholded", frame);
    cv::waitKey(10);
  }

  cv_msg.reliability = 0.0f;
  cv_msg.theta = 0.0f;
}

int main(int argc, char **argv){
    // Parser initialisation
  if (!initParser(parser, argc, argv)) return -1;

  // Parser decode
  if (parser.exists("help")){
    parser.print_help();
    return 0;
  }

  // If parser option defined, use it, else default.
  // publish to
  std::string pub_topic = parser.get<std::string>("publish");

  // subscribe to
  std::string sub_topic = parser.get<std::string>("subscribe");

  // name
  std::string node_name = parser.get<std::string>("name") :

  ROS_INFO(" = IPL configuration = ");
  ROS_INFO("Node name: %s", node_name.c_str());
  ROS_INFO("Subscribing to: %s", sub_topic.c_str());
  ROS_INFO("Publishing to: %s", pub_topic.c_str());

  // ROS init
  ros::init(argc, argv, node_name.str().c_str());
  ros::NodeHandle n;

  // Don't use processing link as we aren't republishing an image.
  image_transport::ImageTransport it(n);
  image_transport::Subscriber sub =
    it.subscribe(sub_topic, 1, imageCallback);
  ros::Publisher cv_pub =
    n.advertise<image_processing::centroid_vector>(pub_topic,1000);

  ros::Rate loop_rate(100);
  while (ros::ok()){
    cv_pub.publish(cv_msg);
    ROS_INFO("Published CV: [R:%f, T:%f]",
             cv_msg.reliability,
             cv_msg.theta);
    ros::spinOnce();
    loop_rate.sleep();
  }

  return 0;
}
